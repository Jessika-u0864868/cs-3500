using CustomNetworking;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Text;
using System.Collections.Generic;
using System.Diagnostics;

namespace StringSocketTester
{


    /// <summary>
    ///This is a test class for StringSocketTest and is intended
    ///to contain all StringSocketTest Unit Tests 
    ///</summary>
    [TestClass()]
    public class StringSocketTest
    {


        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext)
        //{
        //}
        //
        //Use ClassCleanup to run code after all tests in a class have run
        //[ClassCleanup()]
        //public static void MyClassCleanup()
        //{
        //}
        //
        //Use TestInitialize to run code before running each test
        //[TestInitialize()]
        //public void MyTestInitialize()
        //{
        //}
        //
        //Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        //public void MyTestCleanup()
        //{
        //}
        //
        #endregion


        /// <summary>
        ///A simple test for BeginSend and BeginReceive
        ///</summary>
        [TestMethod()]
        public void Test1()
        {
            new Test1Class().run(4001);
        }

        public class Test1Class
        {
            // Data that is shared across threads
            private ManualResetEvent mre1;
            private ManualResetEvent mre2;
            private String s1;
            private object p1;
            private String s2;
            private object p2;

            // Timeout used in test case
            private static int timeout = 2000;

            public void run(int port)
            {
                // Create and start a server and client.
                TcpListener server = null;
                TcpClient client = null;

                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    // This will coordinate communication between the threads of the test cases
                    mre1 = new ManualResetEvent(false);
                    mre2 = new ManualResetEvent(false);

                    // Make two receive requests
                    receiveSocket.BeginReceive(CompletedReceive1, 1);
                    receiveSocket.BeginReceive(CompletedReceive2, 2);

                    // Now send the data.  Hope those receive requests didn't block!
                    String msg = "Hello world\nThis is a test\n";
                    foreach (char c in msg)
                    {
                        sendSocket.BeginSend(c.ToString(), (e, o) => { }, null);
                    }

                    // Make sure the lines were received properly.
                    Assert.AreEqual(true, mre1.WaitOne(timeout), "Timed out waiting 1");
                    Assert.AreEqual("Hello world", s1);
                    Assert.AreEqual(1, p1);

                    Assert.AreEqual(true, mre2.WaitOne(timeout), "Timed out waiting 2");
                    Assert.AreEqual("This is a test", s2);
                    Assert.AreEqual(2, p2);
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }
            }

            // This is the callback for the first receive request.  We can't make assertions anywhere
            // but the main thread, so we write the values to member variables so they can be tested
            // on the main thread.
            private void CompletedReceive1(String s, Exception o, object payload)
            {
                s1 = s;
                p1 = payload;
                mre1.Set();
            }

            // This is the callback for the second receive request.
            private void CompletedReceive2(String s, Exception o, object payload)
            {
                s2 = s;
                p2 = payload;
                mre2.Set();
            }
        }

        /// <summary>
        ///A simple test for BeginSend 
        ///</summary>
        [TestMethod()]
        public void Test2()
        {
            new Test2Class().run(4001);
        }

        /// <summary>
        /// This test is only for the BeginSend() method and tests whether or not
        /// the callback is send after the message is comletely sent. This is done by keeping
        /// a counter variable that is incremented when the callback is called.  So if your
        /// BeginSend() did not send a complete message and the callback does not get called,
        /// then the counter will not be incremented and the test will fail.
        /// 
        /// Currently the method only calls BeginSend() once, but if you change the messagesSent
        /// variable, it will increase the number of times we loop through and call BeginSend(), 
        /// and this should be equal to the number of times callback is called, and therefore
        /// equal to the number of times counter is incremented. In short, if you want to change
        /// messagesSend to numbers greater than 1, the test should still pass. 
        /// 
        /// </summary>
        public class Test2Class
        {
            // Data that is shared across threads
            private ManualResetEvent mre;

            // Used in Assert
            int counter = 0;

            // Used in Asser and in loop - if you change this the test should still pass
            int messagesSent = 10;

            public void run(int port)
            {

                // Create and start a server and client.
                TcpListener server = null;
                TcpClient client = null;

                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());                    

                    // Now send the data.  Hope those receive requests didn't block!
                    String msg = "Hello World\nThis is a Test\n";

                    // BeginSend() as many times as messagesSent
                    for (int i = 0; i < messagesSent; i++)
                        sendSocket.BeginSend(msg, Test2Callback, 1);
                    
                    System.Threading.Thread.Sleep(500);
                    Assert.AreEqual(messagesSent, counter);                    
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }

            }

            /// <summary>
            /// Callback increments the counter
            /// </summary>
            /// <param name="s"></param>
            /// <param name="o"></param>
            /// <param name="payload"></param>
            private void Test2Callback(Exception o, object payload)
            {
                counter++;                
            }
        }

        /// <author>Nathan Rollins</author>
        /// <summary>
        /// 
        /// Creates a server which implements a StringSocket object.
        /// Any strings received by this server will be slightly altered  
        /// and automatically sent back to the sender.
        /// 
        /// ServerTestApp and ClientTestApp are heavily adapted from Joe Zachary's 
        /// Simple Chat Server implementation, which was edited by H. James de St. Germain.
        /// </summary>
        public class ServerTestApp
        {
            /// <summary>
            /// The TCP listener which enables us to hear the client's connection attempts.
            /// </summary>
            private TcpListener myTcpListener;

            /// <summary>
            /// Constructor for the ServerTestApp class. Initializes the TCP listener 
            /// to accept connections from any IP address and port 4321. Starts listening
            /// and begins accepting socket connection attempts.
            /// </summary>
            public ServerTestApp()
            {
                // Create the TCP listener to let any IP connect on the port 4321
                myTcpListener = new TcpListener(IPAddress.Any, 4321);

                // Start listening and and accepting socket connection requests.
                myTcpListener.Start();
                myTcpListener.BeginAcceptSocket(ConnectionRequested, null);
            }

            /// <summary>
            /// Callback called when BeginAcceptSocket completes. Creates the socket 
            /// and begins waiting for new connection attempts.
            /// </summary>
            /// <param name="result"></param>
            private void ConnectionRequested(IAsyncResult result)
            {
                // Create a socket to communicate with the client who is requesting it.
                Socket socket = myTcpListener.EndAcceptSocket(result);

                // Create a ClientCommunicator instance to manage the sends and receives.
                new ClientCommunicator(socket);
            }

            /// <summary>
            /// Manages client interactions once a socket has been created. This specific 
            /// implementation creates a StringSocket from the passed connected socket, 
            /// and uses it to easily repeat clients' messages back to them (though slightly
            /// altered).
            /// </summary>
            public class ClientCommunicator
            {
                /// <summary>
                /// The StringSocket enabling us to easily send and receive strings to and from
                /// the client. 
                /// </summary>
                StringSocket serverSocket;

                /// <summary>
                /// The constructor. Converts the passed socket into a StringSocket and begins 
                /// listening for data being sent to it.
                /// </summary>
                /// <param name="socket"></param>
                public ClientCommunicator(Socket socket)
                {
                    // Convert the socket into a StringSocket.
                    serverSocket = new StringSocket(socket, new System.Text.UTF8Encoding());

                    // Start listening for data.
                    serverSocket.BeginReceive(StringReceived, null);
                }

                /// <summary>
                /// Callback called when data is received. Slightly alters the received message, 
                /// and returns it to the sender.
                /// </summary>
                /// <param name="receivedString"></param>
                /// <param name="exceptionReturned"></param>
                /// <param name="payload"></param>
                private void StringReceived(string receivedString,
                    Exception exceptionReturned, object payload)
                {
                    // Send a slightly altered version of the received string back to the sender.
                    // Must include a newline character to terminate the message.
                    serverSocket.BeginSend("I'm not your " + receivedString + "\n", null, null);
                }
            }
        }

        /// <summary>
        /// Creates a client which implements a StringSocket object. Stores the last 
        /// message received from its server in the lastStringReceived variable. Messages
        /// may be sent to the server by calling the SendMessage() method.
        /// 
        /// ServerTestApp and ClientTestApp are heavily adapted from Joe Zachary's 
        /// Simple Chat Server implementation, which was edited by H. James de St. Germain.
        /// </summary>
        public class ClientTestApp
        {
            /// <summary>
            /// Stores the last string received from the server. Will be used by the test to 
            /// ensure proper functionality.
            /// </summary>
            public string lastStringReceived;

            /// <summary>
            /// The StringSocket enabling us to easily send and receive strings to and from
            /// the server. 
            /// </summary>
            private StringSocket clientSocket;

            /// <summary>
            /// The socket which will be built into a StringSocket.
            /// </summary>
            private Socket socket;

            /// <summary>
            /// The constructor. Connects to a server hosted on the local machine through port 4321. 
            /// Once a connection is established, control is transferred to ConnectionEstablished().
            /// </summary>
            public ClientTestApp()
            {
                // Connect to the localhost on port 4321.
                socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                socket.BeginConnect(IPAddress.Loopback, 4321, ConnectionEstablished, null);
            }

            /// <summary>
            /// Callback called when a connection is established. Creates the socket and converts 
            /// it into a StringSocket, then starts listening for data being sent to it.
            /// </summary>
            /// <param name="result"></param>
            private void ConnectionEstablished(IAsyncResult result)
            {
                // Convert the socket into a StringSocket.
                clientSocket = new StringSocket(socket, new UTF8Encoding());

                // Start receiving any incoming data.
                clientSocket.BeginReceive(StringReceived, null);
            }

            /// <summary>
            /// Callback called when string data has been received from the server. 
            /// This test implementation simply stores the received string in the 
            /// lastStringReceived variable.
            /// </summary>
            /// <param name="receivedString"></param>
            /// <param name="exceptionReturned"></param>
            /// <param name="payload"></param>
            private void StringReceived(string receivedString, Exception exceptionReturned, object payload)
            {
                // Store the received string.
                lastStringReceived = receivedString;
            }

            /// <summary>
            /// Allows a string to be sent to the server through this client's StringSocket.
            /// </summary>
            /// <param name="messageToSend"></param>
            public void SendMessage(string messageToSend)
            {
                // Send the message requested.
                clientSocket.BeginSend(messageToSend, null, null);
            }
        }

        /// <author>Nathan Rollins</author>
        /// <timecreated>11/8/2014</timecreated>
        /// <summary>
        /// Creates a server and a client from the custom ServerTestApp and ClientTestApp classes. 
        /// The client sends a message to the server, and the server alters that message to provide 
        /// the expected response.
        /// 
        /// ServerTestApp and ClientTestApp are heavily adapted from Joe Zachary's 
        /// Simple Chat Server implementation, which was edited by H. James de St. Germain.
        /// </summary>
        [TestMethod]
        public void SimpleClientSendServerReceiveTest() // (I like to call it "Lost at the Zoo")
        {
            // Create the server. Its constructor automatically starts listening.
            new ServerTestApp();

            // Create the client and give it some time to connect.
            ClientTestApp testClient = new ClientTestApp();
            Thread.Sleep(1000);

            // Send a message from the client to the server, and give it time to respond.
            testClient.SendMessage("daddy!\n");
            Thread.Sleep(1000);

            // Assert the proper response from the server.
            Assert.AreEqual("I'm not your daddy!", testClient.lastStringReceived);
        }

        /// <summary>
        /// Authors: Greg Smith and Jase Bleazard
        /// Attempts sending the newline character by itself. The sockets should
        /// still send and receive a blank String, "".
        /// </summary>
        [TestMethod()]
        public void SendAndReceiveEmpty()
        {
            new SendAndReceiveEmptyClass().run(4006);
        }

        public class SendAndReceiveEmptyClass
        {
            // Data that is shared across threads
            private ManualResetEvent mre1;
            private String s1;
            private object p1;

            // Timeout used in test case
            private static int timeout = 2000;

            public void run(int port)
            {
                // Create and start a server.
                TcpListener server = null;
                TcpClient client = null;

                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    // This will coordinate communication between the threads of the test cases
                    mre1 = new ManualResetEvent(false);

                    // Make two receive requests
                    receiveSocket.BeginReceive(CompletedReceive1, 1);

                    // Now send the data.  Hope those receive requests didn't block!
                    sendSocket.BeginSend("\n", (e, o) => { }, null);

                    // Make sure the lines were received properly.
                    Assert.AreEqual(true, mre1.WaitOne(timeout), "Timed out waiting 1");
                    Assert.AreEqual("", s1);

                    Assert.AreEqual(1, p1);
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }
            }

            // This is the callback for the first receive request.  We can't make assertions anywhere
            // but the main thread, so we write the values to member variables so they can be tested
            // on the main thread.
            private void CompletedReceive1(String s, Exception o, object payload)
            {
                s1 = s;
                p1 = payload;
                mre1.Set();
            }
        }

        /// <author>Daniel James</author>
        /// <timecreated>11/08/14</timecreated>
        /// <summary>
        /// Tests to make sure that code in callbacks can not cause the StringSocket to get blocked.
        /// </summary>
        [TestMethod()]
        public void TestBlockingCallback()
        {
            // Declare these here so we can properally clean up.
            TcpListener server = null;
            TcpClient client = null;
            StringSocket sendSocket = null;
            StringSocket receiveSocket = null;

            // Test both receive callback and send callback separately.
            ManualResetEvent mreReceive = new ManualResetEvent(false);
            ManualResetEvent mreSend = new ManualResetEvent(false);

            // So we can unblock threads in finally.
            ManualResetEvent mreBlock = new ManualResetEvent(false);

            // Some constants used in the test case
            const int timeout = 2000;
            const int port = 8989;

            try
            {
                // Create server/client
                server = new TcpListener(IPAddress.Any, port);
                server.Start();
                client = new TcpClient("localhost", port);

                // Wrap the two ends of the connection into StringSockets
                sendSocket = new StringSocket(server.AcceptSocket(), new UTF8Encoding());
                receiveSocket = new StringSocket(client.Client, new UTF8Encoding());

                // Make two receive requests
                receiveSocket.BeginReceive((s, e, p) => mreBlock.WaitOne(), 1); // This one attempts to block StringSocket
                receiveSocket.BeginReceive((s, e, p) => mreReceive.Set(), 2); // This one allows assertion to pass. (Won't happen if StringSocket is blocked from the first request.)

                // Make two send requests.
                sendSocket.BeginSend("Don't let my code\n", (e, p) => mreBlock.WaitOne(), null); // This one attempts to block StringSocket
                sendSocket.BeginSend("block your code\n", (e, p) => mreSend.Set(), null); // This one allows assertion to pass. (Won't happen if StringSocket is blocked from the first request.)

                // Make sure the second requests were able to go through.
                Assert.AreEqual(true, mreSend.WaitOne(timeout), "Blocked by BeginSend callback.");
                Assert.AreEqual(true, mreReceive.WaitOne(timeout), "Blocked by BeginReceive callback.");
            }
            finally
            {
                // Cleanup
                mreBlock.Set();
                sendSocket.Close();
                receiveSocket.Close();
                server.Stop();
                client.Close();
            }
        }

        ///<author>Travis Healey</author>
        /// <summary>
        /// 
        /// </summary>
        [TestMethod()]
        public void Test1_Mod()
        {
            for (int i = 0; i < 100; i++)
                new Test1Class().run(4002);

        }

        /// <author>Matthew Madden</author>
        /// <timecreated>11/11/14</timecreated>
        /// <summary>
        /// This method tests whether non-ASCII (multi-byte) characters are
        /// passed through the String Socket intact, based on the encoding provided.
        /// UTF-8 encoding can encode/decode any valid Unicode character.
        ///</summary>
        [TestMethod()]
        public void Test_non_ASCII()
        {
            new TestClass_non_ASCII().run(4100);
        }

        public class TestClass_non_ASCII
        {
            private ManualResetEvent mre1;
            private String msg;
            private object p1;
            StringSocket sendSocket, receiveSocket;

            // Timeout
            private static int timeout = 2000;

            public void run(int port)
            {
                TcpListener server = null;
                TcpClient client = null;


                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;
                    sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    mre1 = new ManualResetEvent(false);

                    receiveSocket.BeginReceive(CompletedReceive, 1);
                    sendSocket.BeginSend("Hêllø Ψórlđ!\n", (e, o) => { }, null);

                    Assert.AreEqual(true, mre1.WaitOne(timeout), "Timed out waiting");
                    // this will fail if the String Socket does not handle non-ASCII characters
                    Assert.AreEqual("Hêllø Ψórlđ!", msg);
                    System.Diagnostics.Debug.WriteLine(msg);
                    Assert.AreEqual(1, p1);
                }
                finally
                {
                    sendSocket.Close();
                    receiveSocket.Close();
                    server.Stop();
                    client.Close();
                }
            }

            //callback
            private void CompletedReceive(String s, Exception o, object payload)
            {
                msg = s;
                p1 = payload;
                mre1.Set();
            }
        }

        ///<author>Josh Oblinsky and Ryan Kingston</author>
        /// <summary>
        ///These are the tests that we created for StringSocketTest
        ///</summary>
        [TestClass()]
        public class SendBeforeReceiveTest
        {

            /// <summary>
            /// Tests to make sure that if Send is called before receive that the string will still be received, and not
            /// discarded. This can happen when the socket is loaded, but does not have any recipients for
            /// it's information.
            ///</summary>
            [TestMethod()]
            public void TestSendBeforeReceive()
            {
                new SendBeforeReceive().run(4001); //Run the test.
            }

            public class SendBeforeReceive
            {
                //Data used by the receiveSocket.
                private ManualResetEvent resetEvent;
                private String receivedString;
                private object receivedPayload;

                // Timeout used in test case
                private static int waitTime = 2000;

                public void run(int port)
                {
                    // Create and start a server and client.
                    TcpListener server = null;
                    TcpClient client = null;

                    try
                    {
                        //Initialize the connection.
                        server = new TcpListener(IPAddress.Any, port);
                        server.Start();
                        client = new TcpClient("localhost", port);

                        // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
                        // method here, which is OK for a test case.
                        Socket serverSocket = server.AcceptSocket();
                        Socket clientSocket = client.Client;

                        // Wrap the two ends of the connection into StringSockets
                        StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                        StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                        // Communicate between the threads of the test cases
                        resetEvent = new ManualResetEvent(false);

                        //Send the string of data to the socket before receive has been called
                        String msg = "This is a test, bro.\n";
                        sendSocket.BeginSend(msg, (e, o) => { }, null);

                        //Make a receive request after data has been read into the socket.
                        receiveSocket.BeginReceive(CompletedReceive1, 1);

                        //Ensure that the data was received correctly.
                        Assert.AreEqual(true, resetEvent.WaitOne(waitTime), "Timed out waiting 1");
                        Assert.AreEqual("This is a test, bro.", receivedString);
                        Assert.AreEqual(1, receivedPayload);
                    }
                    finally
                    {
                        //Stop the server, and discard the socket connection.
                        server.Stop();
                        client.Close();
                    }
                }

                // This is the callback for the receive request.  We can't make assertions anywhere
                // but the main thread, so we write the values to member variables so they can be tested
                // on the main thread.
                private void CompletedReceive1(String s, Exception o, object payload)
                {
                    receivedString = s;
                    receivedPayload = payload;
                    resetEvent.Set();
                }
            }


        }

        /// <author>Xiaobing Rawlinson and Sam Callister</author>
        /// <summary>
        /// Starts the test that will test sending and recieving 5 strings. The test is given
        /// 20 seconds to complete.
        ///</summary>
        [TestMethod()]
        public void MultiStringTest()
        {
            new StressTest().run(4000);
        }

        /// <summary>
        /// This tests sending and recieving 5 strings.
        /// </summary>
        public class StressTest
        {


            // Stores all received strings
            private HashSet<string> receiveStrings = new HashSet<string>();

            // Stores all send strings
            private HashSet<string> sendStrings = new HashSet<string>();

            // Stores all strings that where sent without the \n
            private HashSet<string> correctStrings = new HashSet<string>();

            // Size of strings being handled
            private int size = 5;

            // TIMEOUT USED IN TEST CASE, 20 SECONDS IS USED YOU MAY NEED MORE TIME
            private static int timeout = 20000;

            public void run(int port)
            {
                // Create and start a server and client.
                TcpListener server = null;
                TcpClient client = null;


                try
                {
                    // Set up server and client
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    // This will coordinate communication between the threads of the test cases
                    //mre1 = new ManualResetEvent(false);
                    //mre2 = new ManualResetEvent(false);

                    // Make 5 recieve requests
                    for (int i = 0; i < size; i++)
                    {

                        receiveSocket.BeginReceive(CompletedReceive1, i);
                    }
                    // Send 5 strings
                    for (int i = size; i > 0; i--)
                    {
                        sendStrings.Add(i + " bottles of beer on the wall.\n");
                        correctStrings.Add(i + " bottles of beer on the wall.");
                    }

                    // Send the strings
                    foreach (string s in sendStrings)
                    {
                        sendSocket.BeginSend(s, (e, o) => { }, null);
                    }
                    // Wait to give enough time for the call backs to return
                    Thread.Sleep(timeout);
                    // Ensure that each string was recieved
                    foreach (string s in correctStrings)
                    {
                        // Make sure the lines were received properly.   
                        Assert.IsTrue(receiveStrings.Contains(s));
                    }
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }
            }

            // Callback method that adds each recieved string to the recieveStrings HashSet.
            private void CompletedReceive1(String s, Exception o, object payload)
            {
                receiveStrings.Add(s);

            }
        }

        /// <author> Conan Zhang and April Martin, modifying code provided by Professor de St. Germain</author>
        /// <date> 11-11-14</date>
        /// <summary>
        /// Tests whether threads are processed in the same order they are received, even if the first thread has a ludicrously long
        /// (and therefore slow) message and the second has a short one.
        /// </summary>


        [TestMethod()]
        public void SendOrderTest()
        {
            new SendOrderClass().run(4001);
        }

        /// <summary>
        /// Holds code for SendOrderTest
        /// </summary>
        public class SendOrderClass
        {
            // Data that is shared across threads
            private ManualResetEvent mre1;
            private ManualResetEvent mre2;
            private String slowMsg;
            private object p1;
            private String fastMsg;
            private object p2;

            private int count = 0;
            private int slowOrder;
            private int fastOrder;

            // Timeout used in test case
            private static int timeout = 2000;

            public void run(int port)
            {
                // Create and start a server and client.
                TcpListener server = null;
                TcpClient client = null;

                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // This will coordinate communication between the threads of the test cases
                    mre1 = new ManualResetEvent(false);
                    mre2 = new ManualResetEvent(false);

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    // Set slowMsg to an absurdly long string that should take a while to process.
                    // Set fastMsg to a single character.
                    slowMsg = @"{{About|the video game character|other uses|Kirby (disambiguation){{!}}Kirby}}
                    {{Infobox VG character
                    | width = 220px
                    | name = Kirby
                    | image = [[File:Kirby Wii.png|225px]]
                    | caption = Kirby as he appears in ''[[Kirby's Return to Dream Land]]''
                    | series = [[Kirby (series)|''Kirby'' series]]
                    | firstgame = ''[[Kirby's Dream Land]]'' (1992)
                    | creator = [[Masahiro Sakurai]]
                    | artist = Masahiro Sakurai
                    | japanactor = [[Mayumi Tanaka]] (1994)<br>[[Makiko Ohmoto]] (1999-present)
                    }}
                    {{nihongo|'''Kirby'''|カービィ|Kābī}} is a [[Character (arts)|fictional character]] and the protagonist of the 
                    ''[[Kirby (series)|Kirby series]]'' of video games owned by [[Nintendo]]. As one of Nintendo's most famous and familiar icons, 
                    Kirby's round, pink appearance and ability to copy his foe's powers to use as his own has made him a well known figure in video 
                    games, consistently ranked as one of the most iconic video game characters. He made his first appearance in 1992 in ''[[Kirby's 
                    Dream Land]]'' for the [[Game Boy]]. Originally a placeholder, created by [[Masahiro Sakurai]], for the game's early development, 
                    he has since then starred in over 20 games, ranging from [[Action game|action]] [[Platform game|platformers]] to [[Kirby's Pinball
                    Land|pinball]], [[Puzzle game|puzzle]] and [[Kirby Air Ride|racing]] games, and has been featured as a playable fighter in all 
                    ''[[Super Smash Bros.]]'' games. He has also starred in his own [[Kirby: Right Back at Ya|anime]] and manga series. His most 
                    recent appearance is in ''[[Super Smash Bros. for Nintendo 3DS and Wii U]]'', released in 2014 for the [[Nintendo 3DS]] and [[Wii 
                    U]]. Since 1999, he has been voiced by [[Makiko Ohmoto]].
                    Kirby is famous for his ability to inhale objects and creatures to obtain their attributes, as well as his ability to float with 
`                   puffed cheeks. He uses these abilities to rescue various lands, such as his home world of Dream Land, from evil forces and 
                    antagonists, such as [[Dark Matter (Kirby)|Dark Matter]] or [[Nightmare (Kirby)|Nightmare]]. On these adventures he often crosses 
                    paths with his rivals, the gluttonous [[King Dedede]] and the mysterious [[Meta Knight]]. In virtually all his appearances,
                    Kirby is depicted as cheerful, innocent, and food loving but becomes fearless, bold, and brave in the face of danger.
                    == Concept and creation ==";
                    fastMsg = "!";

                    // Send slowMsg before fastMsg
                    sendSocket.BeginSend(slowMsg, slowCallback, 1);
                    sendSocket.BeginSend(fastMsg, fastCallback, 2);

                    // Make sure that (a) neither thread timed out and
                    //(b) slowMsg was sent successfully before fastMsg
                    Assert.AreEqual(true, mre1.WaitOne(timeout), "Timed out waiting 1");
                    Assert.AreEqual(0, slowOrder);
                    Assert.AreEqual(1, p1);

                    Assert.AreEqual(true, mre2.WaitOne(timeout), "Timed out waiting 2");
                    Assert.AreEqual(1, fastOrder);
                    Assert.AreEqual(2, p2);
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }
            }

            /// <summary>
            /// This is the callback for the first send request.  We can't make assertions anywhere
            /// but the main thread, so we write the values to member variables so they can be tested
            /// on the main thread.
            /// </summary>
            /// <param name="s"></param>
            /// <param name="o"></param>
            /// <param name="payload"></param>
            private void slowCallback(Exception o, object payload)
            {
                slowOrder = count;
                count++;
                p1 = payload;
                mre1.Set();
            }

            /// <summary>
            /// This is the callback for the second send request.
            /// </summary>
            /// <param name="s"></param>
            /// <param name="o"></param>
            /// <param name="payload"></param>
            private void fastCallback(Exception o, object payload)
            {
                fastOrder = count;
                count++;
                p2 = payload;
                mre2.Set();
            }
        }

        /// <author>Kirk Partridge, Kameron Paulsen</author>
        /// <timecreated>11/12/14</timecreated>
        /// <summary>
        /// This method tests the StringSockets ability
        /// to Send Multiple strings before the BeginReceive
        /// is called.  It Sends both by single characters
        /// and full Strings.
        ///</summary>
        [TestMethod()]
        public void MultipleSendBeforeReceiveTest()
        {
            new MultipleSendBeforeReceive().run(4001);
        }
        public class MultipleSendBeforeReceive
        {
            // Data that is shared across threads
            private ManualResetEvent mre1;
            private ManualResetEvent mre2;
            private ManualResetEvent mre3;
            private String s1;
            private object p1;
            private String s2;
            private object p2;
            private String s3;
            private object p3;

            // Timeout used in test case
            private static int timeout = 2000;

            public void run(int port)
            {
                // Create and start a server and client.
                TcpListener server = null;
                TcpClient client = null;

                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    // This will coordinate communication between the threads of the test cases
                    mre1 = new ManualResetEvent(false);
                    mre2 = new ManualResetEvent(false);
                    mre3 = new ManualResetEvent(false);



                    // Now send the data.  Hope those receive requests didn't block!
                    String msg = "Hello world\nThis is a test\nStrings";
                    foreach (char c in msg)
                    {
                        sendSocket.BeginSend(c.ToString(), (e, o) => { }, null);
                    }
                    //Second Message to be sent
                    String msg2 = " sure are neat\n";
                    //Send the second message.  Should be appended to the leftovers from the foreach loop ("String").
                    sendSocket.BeginSend(msg2, (e, o) => { }, null);

                    receiveSocket.BeginReceive(CompletedReceive1, 1);
                    receiveSocket.BeginReceive(CompletedReceive2, 2);
                    receiveSocket.BeginReceive(CompletedReceive3, 3);

                    // Make sure the lines were received properly.
                    Assert.AreEqual(true, mre1.WaitOne(timeout), "Timed out waiting 1");
                    Assert.AreEqual("Hello world", s1);
                    Assert.AreEqual(1, p1);

                    Assert.AreEqual(true, mre2.WaitOne(timeout), "Timed out waiting 2");
                    Assert.AreEqual("This is a test", s2);
                    Assert.AreEqual(2, p2);

                    Assert.AreEqual(true, mre3.WaitOne(timeout), "Timed out waiting 3");
                    Assert.AreEqual("Strings sure are neat", s3);
                    Assert.AreEqual(3, p3);
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }
            }

            // This is the callback for the first receive request.  We can't make assertions anywhere
            // but the main thread, so we write the values to member variables so they can be tested
            // on the main thread.
            private void CompletedReceive1(String s, Exception o, object payload)
            {
                s1 = s;
                p1 = payload;
                mre1.Set();
            }

            // This is the callback for the second receive request.
            private void CompletedReceive2(String s, Exception o, object payload)
            {
                s2 = s;
                p2 = payload;
                mre2.Set();
            }
            // This is the callback for the third receive request.
            private void CompletedReceive3(String s, Exception o, object payload)
            {
                s3 = s;
                p3 = payload;
                mre3.Set();
            }
        }

        /// <author>Jake Anderson and Christopher Bowcutt</author>
        /// <summary>
        /// Test to check that StringSocket receives lines ending with \r instead of \n
        /// Note: This is modeled after the given Test1
        /// </summary>
        [TestMethod]
        public void CarriageReturnTest()
        {

            new TestCarriageReturnClass().run(4002);

        }

        /// <summary>
        /// Class used to run CarriageReturnText
        /// </summary>
        public class TestCarriageReturnClass
        {
            // Data that is shared across threads
            private ManualResetEvent mre1;
            private ManualResetEvent mre2;
            private String s1;
            private object p1;
            private String s2;
            private object p2;

            // Timeout used in test case
            private static int timeout = 2000;

            public void run(int port)
            {
                // Create and start a server and client.
                TcpListener server = null;
                TcpClient client = null;

                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection. We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    // This will coordinate communication between the threads of the test cases
                    mre1 = new ManualResetEvent(false);
                    mre2 = new ManualResetEvent(false);

                    // Make two receive requests
                    receiveSocket.BeginReceive(CompletedReceive1, 1);
                    receiveSocket.BeginReceive(CompletedReceive2, 2);

                    // Now send the data. Hope those receive requests didn't block!
                    // NOTE: This is the line that has been changed
                    String msg = "Hello world\r\nThis is a test\r\n";
                    foreach (char c in msg)
                    {
                        sendSocket.BeginSend(c.ToString(), (e, o) => { }, null);
                    }

                    // Make sure the lines were received properly.
                    Assert.AreEqual(true, mre1.WaitOne(timeout), "Timed out waiting 1");
                    Assert.AreEqual("Hello world", s1);
                    Assert.AreEqual(1, p1);

                    Assert.AreEqual(true, mre2.WaitOne(timeout), "Timed out waiting 2");
                    Assert.AreEqual("This is a test", s2);
                    Assert.AreEqual(2, p2);
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }
            }

            // This is the callback for the first receive request. We can't make assertions anywhere
            // but the main thread, so we write the values to member variables so they can be tested
            // on the main thread.
            private void CompletedReceive1(String s, Exception o, object payload)
            {
                s1 = s;
                p1 = payload;
                mre1.Set();
            }

            // This is the callback for the second receive request.
            private void CompletedReceive2(String s, Exception o, object payload)
            {
                s2 = s;
                p2 = payload;
                mre2.Set();
            }
        }

        /// <summary>
        /// <author>Albert Tom, Matthew Lemon</author>
        /// This test stress tests the socket on sending long strings all at once
        /// Quotes provided by Jedi Master and super spy Liam Neeson
        /// </summary>

        [TestMethod()]
        public void LongStringTest()
        {
            new LongStringTestClass().run(4001);
        }

        public class LongStringTestClass
        {
            // Data that is shared across threads
            private ManualResetEvent mre1;
            private ManualResetEvent mre2;
            private String s1;
            private object p1;
            private String s2;
            private object p2;

            // Timeout used in test case
            private static int timeout = 2000;

            public void run(int port)
            {
                // Create and start a server and client.
                TcpListener server = null;
                TcpClient client = null;

                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection. We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    // This will coordinate communication between the threads of the test cases
                    mre1 = new ManualResetEvent(false);
                    mre2 = new ManualResetEvent(false);

                    // Make two receive requests
                    receiveSocket.BeginReceive(CompletedReceive1, 1);
                    receiveSocket.BeginReceive(CompletedReceive2, 2);

                    // Now send the data. Stress test long strings
                    String msg = "I don't have money. But what I do have are a very particular set of skills acquired over a very long career in the shadows, skills that make me a nightmare for people like you. If you let my daughter go now, that will be the end of it. I will not look for you, I will not pursue you. But if you don't, I will look for you, I will find you. And I will kill you\nI don't have anything else. [waves hand] But credits will do fine.\n";

                    sendSocket.BeginSend(msg, (e, o) => { }, null);

                    // Make sure the lines were received properly.
                    Assert.AreEqual(true, mre1.WaitOne(timeout), "Timed out waiting 1");
                    Assert.AreEqual("I don't have money. But what I do have are a very particular set of skills acquired over a very long career in the shadows, skills that make me a nightmare for people like you. If you let my daughter go now, that will be the end of it. I will not look for you, I will not pursue you. But if you don't, I will look for you, I will find you. And I will kill you", s1);
                    Assert.AreEqual(1, p1);

                    Assert.AreEqual(true, mre2.WaitOne(timeout), "Timed out waiting 2");
                    Assert.AreEqual("I don't have anything else. [waves hand] But credits will do fine.", s2);
                    Assert.AreEqual(2, p2);
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }
            }

            // This is the callback for the first receive request. We can't make assertions anywhere
            // but the main thread, so we write the values to member variables so they can be tested
            // on the main thread.
            private void CompletedReceive1(String s, Exception o, object payload)
            {
                s1 = s;
                p1 = payload;
                mre1.Set();
            }

            // This is the callback for the second receive request.
            private void CompletedReceive2(String s, Exception o, object payload)
            {
                s2 = s;
                p2 = payload;
                mre2.Set();
            }
        }

        /// <summary>
        /// Author: Ryan Farr
        /// A simple test to make sure Close() works
        ///</summary>
        [TestMethod()]
        [ExpectedException(typeof(System.ObjectDisposedException))]
        public void TestCloseBasic()
        {
            TcpListener server = new TcpListener(IPAddress.Any, 4006);
            server.Start();
            TcpClient client = new TcpClient("localhost", 4006);

            Socket serverSocket = server.AcceptSocket();
            Socket clientSocket = client.Client;

            StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
            StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

            sendSocket.Close();
            receiveSocket.Close();

            bool test1 = serverSocket.Available == 0; //Should fail here because socket should be shutdown and closed
        }

        /// <summary>
        /// @Author Eric Albee
        /// @Author Douglas Canada
        /// Testing foreign and odd Chars
        /// in large quanity to see if the
        /// socket is recieving the correct sequence.
        /// November 12, 2014
        /// </summary>
        [TestMethod()]
        public void beeCanForeignTest()
        {
            new ForeignTest().run(4001);
        }

        public class ForeignTest
        {
            // Data that is shared across threads
            private ManualResetEvent mre1;
            private String s1 = "";
            private object p1;

            // Timeout used in test case
            private static int timeout = 2000;

            public void run(int port)
            {
                // Create and start a server and client.
                TcpListener server = null;
                TcpClient client = null;

                try
                {
                    server = new TcpListener(IPAddress.Any, port);
                    server.Start();
                    client = new TcpClient("localhost", port);

                    // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
                    // method here, which is OK for a test case.
                    Socket serverSocket = server.AcceptSocket();
                    Socket clientSocket = client.Client;

                    // Wrap the two ends of the connection into StringSockets
                    StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
                    StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

                    // This will coordinate communication between the threads of the test cases
                    mre1 = new ManualResetEvent(false);

                    // Make a receive request
                    receiveSocket.BeginReceive(CompletedReceive, 1);

                    String msg = "";
                    int SIZE = 1000;
                    string[] letters = new string[SIZE];
                    for (int i = 0; i < SIZE; i++)
                    {
                        letters[i] = (msg + (char)('a' + i));
                    }

                    string sentMessage = "";
                    for (int i = 0; i < SIZE; i++)
                    {
                        sendSocket.BeginSend(letters[i], (e, o) => { }, null);

                        // building the message to be asserted
                        sentMessage += letters[i];
                    }

                    sendSocket.BeginSend("\n", (e, o) => { }, null);

                    // Make sure the line was received properly.
                    Assert.AreEqual(true, mre1.WaitOne(timeout), "Timed out waiting 1");
                    Assert.AreEqual(sentMessage, s1);
                    Assert.AreEqual(1, p1);
                }
                finally
                {
                    server.Stop();
                    client.Close();
                }
            }

            // This is the callback for the receive request.  We can't make assertions anywhere
            // but the main thread, so we write the values to member variables so they can be tested
            // on the main thread.
            private void CompletedReceive(String s, Exception o, object payload)
            {
                s1 += s;
                p1 = payload;
                mre1.Set();
            }
        }

        /// <summary>
        /// Authors: Ryan Welling and Jared Jensen
        /// 
        /// This method opens sockets, begins sending and then closes them
        /// and tries sending again after it has been closed.  Expects Exception
        /// </summary>
        [TestMethod()]
        [ExpectedException(typeof(ObjectDisposedException))]
        public void CloseTest2()
        {
            // Create and start a server and client.
            TcpListener server = null;
            TcpClient client = null;

            server = new TcpListener(IPAddress.Any, 4042);
            server.Start();
            client = new TcpClient("localhost", 4042);

            // Obtain the sockets from the two ends of the connection.  We are using the blocking AcceptSocket()
            // method here, which is OK for a test case.
            Socket serverSocket = server.AcceptSocket();
            Socket clientSocket = client.Client;

            // Wrap the two ends of the connection into StringSockets
            StringSocket sendSocket = new StringSocket(serverSocket, new UTF8Encoding());
            StringSocket receiveSocket = new StringSocket(clientSocket, new UTF8Encoding());

            // This will coordinate communication between the threads of the test cases
            ManualResetEvent mre1 = new ManualResetEvent(false);
            ManualResetEvent mre2 = new ManualResetEvent(false);

            // Make two receive requests
            receiveSocket.BeginReceive((s, e, o) => { }, 1);
            receiveSocket.BeginReceive((s, e, o) => { }, 2);

            // Now send the data.  
            string msg1 = "Hello world\n";
            string msg2 = "This is a test\n";

            sendSocket.BeginSend(msg1, (e, o) => { }, null);
            sendSocket.Close();

            // should throw exception, socket was closed
            sendSocket.BeginSend(msg2, (e, o) => { }, null);
        }
    }
}
